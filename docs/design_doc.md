# AHCAgent デザインドキュメント

**バージョン:** 1.0
**最終更新日:** 2025-05-30
**ステータス:** 完成

## 目次

1.  はじめに
    1.1. プロジェクトの目的
    1.2. 背景
    1.3. 解決する課題
2.  対象読者
3.  プロダクトの目標
    3.1. 機能目標
    3.2. 非機能目標
4.  スコープ (対象範囲)
    4.1. 対象とする機能 (In Scope)
    4.2. 対象としない機能 (Out of Scope)
5.  主要機能とユースケース
    5.1. ユースケース 1: 新しい AHC コンテストへの参加準備と初期解探索
    5.2. ユースケース 2: 設定変更と実験の再開
6.  アーキテクチャ
    6.1. 全体構成図
    6.2. 主要コンポーネント詳細
    6.3. データフロー
7.  UI/UX (CLI)
    7.1. コマンド体系
    7.2. 対話モードの主要なやり取り (`solve --interactive`)
    7.3. 出力とログ
8.  データモデル
    8.1. 設定ファイル (`config.yaml`)
    8.2. 問題分析結果 (JSON)
    8.3. 個体 (Solution Candidate)
    8.4. セッション情報
9.  考慮事項
    9.1. セキュリティ
    9.2. パフォーマンス
    9.3. エラーハンドリングとリトライ
    9.4. ロギング
10. 将来の展望 (マイルストーン外)
11. 用語集
12. テスト計画
    12.1. テスト戦略
    12.2. テストの種類と対象

---


## 1\. はじめに

### 1.1. プロジェクトの目的

AtCoder Heuristic Contest (AHC) の問題解決プロセスを自動化・支援するためのスタンドアロン CLI ツールを提供します。LLM を活用した高度な問題分析、戦略立案、DeepMind の AlphaEvolve にインスパイアされた進化的アルゴリズムによる解探索、C++コード生成・実行・デバッグまでを一貫してサポートすることを目指します。さらに、典型アルゴリズムの提供や過去コンペの解法データベースを活用することで、競技プログラマーの生産性向上と効率的な解法探索に貢献する。

### 1.2. 背景

AHC のようなヒューリスティック型コンテストでは、問題の特性把握、多様な解法の試行、パラメータ調整といった多岐にわたる作業が求められ、多くの時間と労力を要します。特に、LLM の能力を最大限に活用しつつ、ローカル環境で完結し、かつ再現性の高い開発・実験サイクルを効率的に回すためのツールが不足しています。AlphaEvolve のようなアプローチは、LLM をコーディングエージェントとして活用し、アルゴリズム設計自体を進化させる可能性を示しており、本ツールはこの思想を AHC の文脈で実現することを目指します。また、過去の知見や汎用的なアルゴリズム部品の再利用を促進することで、車輪の再発明を防ぎ、より高度な戦略に注力できる環境を提供する。

### 1.3. 解決する課題

  - AHC 問題解決における定型的な作業（問題分析、コードの雛形作成、コンパイル・実行、簡単な実験管理など）の自動化。
  - LLM を用いた問題分析・戦略提案による、解法アプローチの多様化と質の向上。
  - AlphaEvolve に着想を得た、LLM によるコード生成・変異・交叉を伴う進化的アルゴリズムによる解探索プロセスの自動化と効率化。
  - Docker を用いた再現可能かつ分離された実行環境の提供。
  - ローカル環境での開発・実験サイクルの高速化。
  - コンテスト開始時の環境構築の自動化（問題文、公式ツール等の取得とセットアップ）。
- 典型的なアルゴリズムやデータ構造のライブラリへの容易なアクセスと利用。
- 過去のコンテスト問題とそれに対する有望な解法アプローチのデータベース化と検索・参照。


## 2\. 対象読者

このドキュメントは、以下の関係者を対象としています。

  - 開発者
  - プロジェクト貢献者

## 3\. プロダクトの目標

### 3.1. 機能目標

  - **問題分析**: LLM を使用して AHC の問題文を解析し、制約、入出力形式、スコアリングルールなどを構造化して抽出できる。
- **戦略提案**: 分析結果に基づき、LLM が複数の解法戦略やアルゴリズムのアイデアを提案できる。必要に応じて、内蔵の典型アルゴリズムライブラリや過去の解法データベースを参照し、提案に含めることができる。
  - **コード生成**: 選択された戦略に基づき、C++の基本的な実装コードを生成できる。
- **進化的解探索 (AlphaEvolve 風)**: 生成されたコードをベースに、LLM を主要なオペレータ (変異、交叉、新規生成など) として活用する AlphaEvolve に類似した進化的アルゴリズムを実行し、解を改善できる。これには、LLM によるコードの理解、改善提案、バグ修正の試みも含む。
  - **ローカル実行・評価**: Docker コンテナ内で C++コードを安全にコンパイル・実行し、評価できる。
  - **実験管理**: 実行した実験のパラメータ、生成されたコード、スコアなどを記録・管理できる。
  - **CLI 操作**: 上記機能を直感的なコマンドラインインターフェースから操作できる。
      - **プロジェクト初期化 (`init <CONTEST_ID>`)**: コンテスト ID を指定してプロジェクトを初期化する。ワークスペース作成、問題文・公式ツール群のダウンロード、設定ファイルの生成などを行う。
      - **問題解決プロセスの実行 (`solve <WORKSPACE>`)**: 指定されたワークスペースで解探索を開始する。
  - **対話モード**: `solve` コマンドの `--interactive` オプションにより、ユーザーがステップごとに確認・介入しながら問題解決プロセスを進められる。
  - **典型アルゴリズム・ライブラリ**: 頻出するアルゴリズム（焼きなまし法、ビームサーチ、ダイクストラ法など）やデータ構造（Union-Find 木など）の C++実装を提供し、エージェントが容易に利用できるようにする。
- **過去コンペ解法データベース**: 過去の AHC 問題の概要、特徴、上位解法で用いられたアプローチやアルゴリズムの情報をデータベース化し、キーワードや問題特性で検索・参照できるようにする。

### 3.2. 非機能目標

  - **ユーザビリティ**: CLI のコマンドやオプションは直感的で理解しやすいものにする。
  - **パフォーマンス**: 問題分析やコード生成、小規模な実験実行は妥当な時間内に完了する。
  - **拡張性**: 新しい LLM モデルやアルゴリズムへの対応を考慮した設計にする。典型アルゴリズムライブラリや解法 DB への追加・更新も容易であること。
  - **再現性**: Docker コンテナの利用により、異なる環境でも実験結果の再現性を担保する。
  - **保守性**: モジュール化されたクリーンなコードベースを維持する。

---


## 4\. スコープ (対象範囲)

### 4.1. 対象とする機能 (In Scope)

  - 上記「3.1. 機能目標」に記載された機能。
  - AtCoder Heuristic Contest の問題形式への特化。
  - `init` コマンドによる、コンテスト環境の自動セットアップ機能。
  - LLM として `LiteLLM` がサポートするモデルへの対応。
  - 解法コードの主言語として C++をサポート。
  - ローカルファイルシステムへの実験結果の保存。
  - AlphaEvolve の主要なアイデアの導入。
  - 基本的な典型アルゴリズム・データ構造の C++ライブラリの提供と、それらをエージェントが参照・利用する仕組み。
- 過去の AHC 問題のメタデータと解法パターンの小規模なデータベースの構築と、CLI からの簡易的な検索・参照機能。

### 4.2. 対象としない機能 (Out of Scope)

  - GUI インターフェースの提供。
  - クラウドベースの大規模分散実行環境の構築・管理。
  - 複数ユーザーによる同時利用・共有機能。
  - AHC 以外のコンテスト形式への汎用的な対応。
  - 複雑な数式処理や高度な数学的解析機能の組み込み。
  - 解答の自動提出機能。
  - LLM のファインチューニング機能。
  - AlphaEvolve 論文で言及されているような発見的アルゴリズムの完全な自動設計。
  - `init` コマンドにおける、非公式なツールや複雑な依存関係を持つツールの自動セットアップ。

---


## 5\. 主要機能とユースケース

### 5.1. ユースケース 1: 新しい AHC コンテストへの参加準備と初期解探索

1.  ユーザーはコンテストページでコンペティション ID（例: `ahc030`）を確認します。
2.  ユーザーはターミナルで `ahc-agent init ahc030` を実行します。
      - システムは `./ahc030/` のようなワークスペースディレクトリ（指定がなければ）を作成します。
      - システムは公式ページ等から問題文、テスト入力例を含む公式ツール群（例: `tools.zip`）をダウンロードし、ワークスペース内に適切に配置・セットアップします。
      - システムは `config.yaml` をワークスペース内に生成します。
3.  ユーザーは `cd ./ahc030` でワークスペースに移動します。
4.  ユーザーは必要に応じてワークスペース内の `config.yaml` を編集し、LLM のモデルや進化計算のパラメータを調整します。
5.  ユーザーは `ahc-agent solve .` （カレントディレクトリがワークスペースの場合）または `ahc-agent solve ./ahc030` を実行します。
      - エージェントは問題分析、戦略立案、初期コード生成、そして AlphaEvolve 風の進化プロセスを開始します。
      - 進捗はコンソールに出力され、セッションデータはワークスペース内に保存されます。
      - `--interactive` オプションをつけることで、対話的に各ステップを進めることも可能です。

### 5.2. ユースケース 2: 設定変更と実験の再開

1.  ユーザーは前回の `solve` コマンドで作成されたワークスペース内の `config.yaml` を編集し、例えば LLM モデルや進化計算のパラメータを変更します。
2.  ユーザーは `ahc-agent solve . --session-id <previous_session_id>` を実行し、前回のセッションの途中から、または新しい設定に基づき初期状態から解探索を再開（または新規開始）します。既存の分析結果や戦略、最良解は可能な範囲で再利用されます。

---


## 6\. アーキテクチャ

（このセクションは、以前の回答で提供された修正済みのアーキテクチャ図とパッケージ構造を挿入します。ここでは省略します。）
\-\> `docs/architecture.md` の該当セクションを参照してください。

---


## 7\. UI/UX (CLI)

### 7.1. コマンド体系

  - `ahc-agent init <CONTEST_ID> [OPTIONS]`
      - 例: `ahc-agent init ahc030`
      - オプション:
          - `--workspace PATH` (`-w`): プロジェクトを作成するディレクトリ。指定がない場合はカレントディレクトリに `<CONTEST_ID>` 名のディレクトリを作成。
          - `--html FILE_PATH`: 問題文を含むローカルHTMLファイルのパスを指定します。指定された場合、AtCoderのウェブサイトから取得する代わりに、このファイルから問題文を解析します。問題文をローカルに保存している場合や、ウェブアクセスが利用できない/失敗する場合に便利です。
  - `ahc-agent solve <WORKSPACE> [OPTIONS]`
      - 例: `ahc-agent solve ./my_ahc_project`
      - オプション:
          - `WORKSPACE`: (必須) 初期化済みのワークスペースディレクトリのパス。
          - `--session-id ID` (`-s`): 既存のセッションIDを指定して処理を再開/継続。
          - `--interactive` (`-i`): 対話モードで起動。

### 7.2. 対話モードの主要なやり取り (`ahc-agent solve --interactive`)

1.  問題分析結果の表示と確認プロンプト。
2.  戦略提案の表示とユーザーによる選択・調整プロンプト。
3.  初期コード生成の確認プロンプト。
4.  進化プロセス中の定期的な進捗表示 (世代、ベストスコアなど)。
5.  ユーザープロンプト (` >  `) が表示され、以下の様なコマンドで指示入力可能:
      - `analyze`: 問題分析の実行と結果表示。
      - `strategy`: 解法戦略の立案と結果表示。
      - `testcases`: テストケースの生成とスコア計算機の準備。
      - `initial`: 初期解の生成と保存。
      - `evolve`: 進化プロセスの実行と結果表示。
      - `status`: 現在のセッションの状態（分析、戦略、テストケース、最良スコアなど）を表示。
      - `help`: 利用可能なコマンドを表示。
      - `exit`: 対話モードを終了。

### 7.3. 出力とログ

  - **標準出力**: 主要な情報、進捗、ユーザーへのプロンプト (対話モード時)。
  - **標準エラー出力**: エラーメッセージ、警告。
  - **ログファイル**:
      - セッションログ: `workspace/<CONTEST_ID>/sessions/<SESSION_ID>/logs/session.log` (DEBUG レベル以上の詳細な実行記録、LLM との全プロンプト・レスポンス、各オペレーションの所要時間など) のような構造で保存されます（具体的なパスは `KnowledgeBase` の実装に依存）。
  - **成果物 (ワークスペース内)**:
      - 問題ファイル: `<WORKSPACE>/problem.md`
      - 公式ツール類: `<WORKSPACE>/tools/` (例: `tester/`, `visualizer/`, `in/`)
      - 設定ファイル: `<WORKSPACE>/config.yaml`
      - セッションデータ: `<WORKSPACE>/sessions/<SESSION_ID>/` 以下に、分析結果、戦略、生成されたC++コード群、評価結果、進化ログなどが構造的に保存されます。
          - 例: `solutions/gen<世代番号>_id<個体ID>_score<スコア>.cpp`
          - 例: `best_solution.cpp` (最終的な最良解)

---


## 8\. データモデル

### 8.1. 設定ファイル (`config.yaml`)

ワークスペースごとに配置され、LLM設定、Docker設定、進化パラメータなどを定義します。`init` コマンド実行時にデフォルト値で生成され、ユーザーが編集可能です。

### 8.2. 問題分析結果 (JSON)

`ProblemAnalyzer` によって生成され、問題のタイトル、概要、制約、入出力形式、採点ルールなどが構造化されたJSON形式でセッションデータとして保存されます。

### 8.3. 個体 (Solution Candidate)

進化の各過程で生成・評価される解（C++コード）とそのメタデータ（スコア、生成世代、親個体IDなど）です。セッションデータとして保存されます。

### 8.4. セッション情報

ある `solve` コマンドの実行インスタンスに関する情報。セッションID、開始/終了時刻、ステータス、関連する分析結果・戦略・最良解への参照などが含まれます。

-----


## 9\. 考慮事項

### 9.1. セキュリティ

  - LLM API キーは環境変数で管理し、ログへの直接出力を避けます。
  - Docker コンテナ内でのコード実行により、ローカルシステムへの影響を限定します。
  - `init`でダウンロードするツール類は公式サイトからのものに限定し、安全性を確認します。
  - 外部サイトへのアクセスは HTTPS を強制し、信頼できるソースからのみ行います。

### 9.2. パフォーマンス

  - LLM へのリクエストは必要な情報に絞り、トークン数を最適化します。
  - C++コードのコンパイル・実行は効率的に行います。
  - 長時間実行される進化プロセスでは、定期的な状態保存とリソース監視を考慮します。

### 9.3. エラーハンドリングとリトライ

  - LLM API 通信エラー、Docker 実行エラー、コードのコンパイル/実行時エラーなどを適切に捕捉し、ユーザーに分かりやすいエラーメッセージを提示します。
  - LLM API の一時的なエラーに対してはリトライ機構を設けます。
  - `init` コマンドでのファイルダウンロード失敗時はリトライ処理を検討します。

### 9.4. ロギング

  - ログレベル (DEBUG, INFO, WARNING, ERROR, CRITICAL) を設定可能にします。
  - セッションごとの詳細ログをファイルに記録します。
  - LLM とのプロンプトとレスポンスの主要部分をログに記録します。

-----


## 10\. 将来の展望 (マイルストーン外)

  - 対応プログラミング言語の追加 (Python, Rust など)。
  - より高度な知識ベースの活用。
  - 分散実行による大規模実験のサポート。
  - 結果の可視化ツールの統合。
  - より洗練された自然言語によるエージェントへの指示・対話機能。
  - マルチモーダル LLM を活用した問題図表の解析。

-----


## 11\. 用語集

  - **AHC**: AtCoder Heuristic Contest
  - **LLM**: Large Language Model (大規模言語モデル)
  - **AlphaEvolve**: DeepMindによって提案された、進化的アルゴリズムとLLMを組み合わせてコードを生成・改善する手法。
  - **ワークスペース**: 特定のコンテスト問題に対する作業ディレクトリ。`problem.md`, `config.yaml`, `tools/`, セッションデータなどが格納される。
  - **セッション**: `ahc-agent solve` コマンドの一回の実行（または再開された実行）に対応するデータの集合。

-----


## 12\. テスト計画

### 12.1. テスト戦略

  - **テストピラミッド**: 単体テストを主軸に、統合テスト、主要なE2Eテストを実施。
  - **自動化**: CI を通じてテストを自動実行。
  - **カバレッジ目標**: 主要モジュールで高いカバレッジを目指す。
  - **モックとスタブの活用**: 外部依存をモック化し、テストの安定性と速度を向上。

### 12.2. テストの種類と対象

  - **単体テスト (Unit Tests)**:
      - 対象: 各モジュール内の個々の関数、クラスのメソッド。
      - ツール: `pytest`, `unittest.mock`.
  - **統合テスト (Integration Tests)**:
      - 対象: 複数モジュール間のインターフェースと連携。例: `LLMClient` と `ProblemAnalyzer`、`DockerManager` と `ImplementationDebugger`。
      - ツール: `pytest`, Docker SDK, モックサーバー。
  - **E2E テスト (End-to-End Tests)**:
      - 対象: 主要な CLI コマンド (`ahc-agent init`, `ahc-agent solve`) の一連のフロー。
      - ツール: `pytest` + `subprocess` モジュール。
